# 项目架构与业务逻辑设计

## 一、架构概览

本项目采用**模块化设计**，清晰分离关注点：

```
用户交互层 (User Interaction)
        ↓
   主程序 (main.c)
        ↓
业务逻辑层 (Business Logic)
        ↓
转换模块 (converter.c)
        ↓
数据结构与接口 (converter.h)
```

## 二、核心模块设计

### 2.1 数据结构 (converter.h)

```c
typedef struct {
    char binary_original[33];    /* 二进制原码 */
    char binary_ones[33];        /* 二进制反码 */
    char binary_twos[33];        /* 二进制补码 */
    char hexadecimal[11];        /* 十六进制数 */
    char octal[12];              /* 八进制数 */
} ConversionResult;
```

**设计理由**：
- 集中存储所有转换结果，便于传递和输出
- 使用固定大小缓冲区，避免动态内存分配的复杂性
- 清晰的字段命名，易于理解和维护

### 2.2 转换流程 (converter.c)

#### 2.2.1 二进制原码转换

```
decimal_to_binary_original()
    ├─ 处理符号位
    │  ├─ 正数: 符号位 = 0
    │  └─ 负数: 符号位 = 1, 取绝对值
    │
    └─ 处理数值位
       ├─ 计算二进制位数
       └─ 从高位到低位提取每一位
```

**示例**：
```
输入: -5
│
├─ 取绝对值: 5
├─ 5 的二进制: 101 (3位)
├─ 符号位: 1
└─ 结果: 11000101 (符号位 + 3位 + 其他补0)
```

#### 2.2.2 反码转换

```
binary_ones_complement()
    │
    ├─ 如果符号位为 0 (正数)
    │  └─ 反码 = 原码 (不变)
    │
    └─ 如果符号位为 1 (负数)
       └─ 除符号位外, 其他各位取反
```

**示例**：
```
原码: 11000101 (-5)
      │││││││└─ 1 -> 0
      ││││││└── 0 -> 1
      │││││└─── 1 -> 0
      ││││└──── 0 -> 1
      │││└───── 0 -> 1
      ││└────── 0 -> 1
      │└─────── 符号位不变: 1
反码: 10111010
```

#### 2.2.3 补码转换

```
binary_twos_complement()
    │
    ├─ 如果符号位为 0 (正数)
    │  └─ 补码 = 原码 (不变)
    │
    └─ 如果符号位为 1 (负数)
       └─ 补码 = 反码 + 1 (从最低位开始进位)
```

**示例**：
```
反码: 10111010
      │││││││└─ 0 + 1 = 1 (进位停止)
补码: 10111011

或者反码: 11111111
      │││││││└─ 1 + 1 = 0 (进位)
      ││││││└── 1 + 1 = 0 (进位)
      ...
补码: 100000000
```

#### 2.2.4 十六进制转换

```
decimal_to_hexadecimal()
    ├─ 处理负号
    ├─ 循环取模 16
    │  ├─ 0-9 映射为字符 '0'-'9'
    │  └─ 10-15 映射为字符 'a'-'f'
    └─ 反序输出
```

#### 2.2.5 八进制转换

```
decimal_to_octal()
    ├─ 处理负号
    ├─ 循环取模 8
    └─ 反序输出
```

## 三、业务逻辑流程

### 3.1 完整转换流程

```
用户输入十进制数
        ↓
    convert_decimal()
        │
        ├─→ decimal_to_binary_original()
        │   获取二进制原码
        │
        ├─→ binary_ones_complement()
        │   根据原码计算反码
        │
        ├─→ binary_twos_complement()
        │   根据反码计算补码
        │
        ├─→ decimal_to_hexadecimal()
        │   计算十六进制表示
        │
        └─→ decimal_to_octal()
            计算八进制表示
        ↓
返回 ConversionResult 结构体
        ↓
print_conversion_result() 格式化输出
```

### 3.2 错误处理

```c
// 每个函数都检查输入参数
if (!buffer || size < 2) {
    return -1;  // 缓冲区不足
}

// 主函数检查子函数的返回值
if (convert_decimal(decimal, &result) != 0) {
    printf("? 转换失败！\n");
    return;
}
```

## 四、代码特色

### 4.1 清晰的职责分离

| 模块 | 职责 | 文件 |
|------|------|------|
| 接口定义 | 函数声明、数据结构、文档 | converter.h |
| 逻辑实现 | 具体的转换算法 | converter.c |
| 用户交互 | 菜单、输入输出、流程控制 | main.c |

### 4.2 详细的注释文档

每个函数都包含：
- 功能描述
- 参数说明
- 返回值说明
- 业务逻辑说明

### 4.3 使用标准 C 类型

```c
#include <stdint.h>

int32_t decimal    // 32位有符号整数，跨平台一致性
```

### 4.4 缓冲区管理

```c
// 足够的缓冲区大小
char binary_original[33];    // 1个符号位 + 32个数值位
char hexadecimal[11];        // 最多10个字符 + 1个空终止符
char octal[12];              // 最多11个字符 + 1个空终止符
```

## 五、实际运行示例

### 示例 1：转换 5

```
√ 符号位 = 0 (正数)
√ 5 的二进制 = 101
√ 原码 = 00000101
√ 反码 = 00000101 (正数不变)
√ 补码 = 00000101 (正数不变)
√ 十六进制 = 5
√ 八进制 = 5
```

### 示例 2：转换 -5

```
√ 符号位 = 1 (负数)
√ 取绝对值 = 5
√ 5 的二进制 = 101
√ 原码 = 11000101 (符号位1 + 数值位000101)
√ 反码 = 10111010 (符号位不变 + 其他位取反)
√ 补码 = 10111011 (反码 + 1)
√ 十六进制 = -5
√ 八进制 = -5
```

## 六、扩展建议

### 6.1 支持不同位宽
```c
// 枚举定义位宽
typedef enum {
    BIT_WIDTH_8 = 8,
    BIT_WIDTH_16 = 16,
    BIT_WIDTH_32 = 32,
    BIT_WIDTH_64 = 64
} BitWidth;
```

### 6.2 支持浮点数
```c
void convert_float(float value, ConversionResult *result);
```

### 6.3 批量转换
```c
void batch_convert(int *decimals, int count, ConversionResult *results);
```

### 6.4 文件 I/O
```c
void save_results_to_file(const char *filename, const ConversionResult *result);
```

## 七、测试用例

| 输入 | 二进制原码 | 二进制反码 | 二进制补码 | 十六进制 | 八进制 |
|------|-----------|-----------|-----------|---------|--------|
| 0 | 00000000 | 00000000 | 00000000 | 0 | 0 |
| 1 | 00000001 | 00000001 | 00000001 | 1 | 1 |
| -1 | 10000001 | 11111110 | 11111111 | -1 | -1 |
| 127 | 01111111 | 01111111 | 01111111 | 7f | 177 |
| -128 | 10000000 | 11111111 | 10000000 | -128 | -200 |
| 255 | 0011111111 | 0011111111 | 0011111111 | ff | 377 |

---

**设计目标**：
? 业务逻辑清晰  
? 代码易于维护  
? 易于扩展和测试  
? 详细的文档注释  
